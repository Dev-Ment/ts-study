# 7장 비동기 호출
비동기 처리를 다룰 때는 다음과 같은 사항을 고려해야 한다.
- 현재 비동기는 어떤 상태인가?
- 비동기 동작을 위해 필요한 정보는 무엇인가?
- 요청이 성공했다면 받아온 정보를 어떻게 저장하고 관리할 것인가?
- 요청이 실패했다면 실패에 대한 정보를 어떻게 확인할 것인가?
- 비동기 요청에 대한 코드를 쉽게 유지보수할 수 있도록 어떻게 구조화하고 관리할 것인가?

## 7.1 API 요청

### 7.1.1 fetch로 API 요청하기
신입 개발자인 개발이는 사용자가 장바구니를 조회해서 볼 수 있는 기능을 만들게 되었다. 그래서 fetch 함수를 이용해 외부 데이터베이스에 접근할 수 있도록 했다.
```typescript
import React, { useEffect, useState } from "react";

const CartBadge: React.FC = () => {
  const [cartCount, setCartCount] = useState(0);

  useEffect(() => {
    fetch("https://api.baemin.com/cart")
      .then((response) => response.json())
      .then(({ cartItem }) => {
        setCartCount(cartItem.length);
      });
  }, []);

  return <>{/*  cartCount 상태를 이용하여 컴포넌트 렌더링 */}</>;
};
```

장바구니 정보를 비동기 함수인 fetch로 불러와 장바구니 내부를 확인하여 장바구니에 담긴 물품의 개수를 배지 아이콘으로 보여주는 기능, 사용자에게 장바구니에 담은 물품을 보여주는 페이지 구현 등 여러 곳에서 같은 API URL을 복붙하여 사용했다. 
하지만 만약 '여러 서버에 API를 요청할 때 타임아웃 설정이 필요하다', '모든 요청에 커스텀 헤더가 필요하다'와 같은 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움이 발생한다.


### 서비스 레이어로 분리하기
여러 API 요청 정책이 추가되어 코드가 변경될 수 있다는 것을 감안한다면, 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역(서비스 레어어)에서 처리되어야 한다.

앞으 코드를 기준으로 설명하면 fetch 함수를 호출하는 부분이 서비스 레이어로 이동하고, 캄포넌트는 서비스 레이어의 비동기 함수를 호출하여 그 결과를 받아와 렌더링하는 흐름이 된다.

그러나 단순히 fetch 함수를 분리하는 것만으로는 API 요청 정책이 추가되는 것을 해결하기 어렵고, 쿼리 매개변수나 커스텀 헤더 추가, 쿠키를 읽어 토큰을 집어넣는 등 다양한 
API 정책이 추가될 수 있는데 이를 모두 구현하는 것은 번거로운 일이다.

```typescript
async function fetchCart() {
  const controller = new AbortController();
  //브라우저에서 제공하는 api로 네트워크 요청을 취소하는 데 사용된다.
  //요청을 취소하려면 controller.abort()를 호출한다.

  const timeoutId = setTimeout(() => controller.abort(), 5000);
  
  const response = await fetch("https://api.baemin.com/cart", {
    signal: controller.signal,
  });

  clearTimeout(timeoutId);

  return response;
}
```

### Axios 활용하기
fetch는 내장 라이브러리이기 때문에 따로 import하거나 설치할 필요 없이 사용이 가능하다. 그러나 많은 기능을 사용하여면 직접 구현해서 사용해야 하는데, 이런 번거러움을 덜어내고자 대신 Axios 라이브러리를 사용하고 있다.

```typescript
import axios, { AxiosInstance, AxiosPromise } from "axios";
// AxiosInstance : Axios를 통해 생성된 인스턴스의 타입이다.
// 이를 사용하면 기본 설정을 공유하는 Axios 인스턴스를 생성할 수 있다.

// AxiosPromise : Axios가 반환하는 Promise의 타입이다.
// 응답 데이터를 제네릭 타입으로 지정할 수 있다.

export type FetchCartResponse = unknown;
export type PostCartRequest = unknown;
export type PostCartResponse = unknown;
// 각 api 요청/응답 타입을 정의한다.

export const apiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.com", // 기본 URL
  timeout: 5000, // 5초뒤 완료되지 않으면 요청 중단
});
// axios.create({}): Axios의 인스턴스를 생성한다.

export const fetchCart = (): AxiosPromise<FetchCartResponse> =>
  apiRequester.get<FetchCartResponse>("cart");
// https://api.baemin.com/cart에 GET요청

export const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<PostCartResponse> =>
  apiRequester.post<PostCartResponse>("cart", postCartRequest);
// https://api.baemin.com/cart에 POST요청
// 요청 본문으로 postCartRequest를 전송
```

각 서버(주문을 처리하는 서버와 장바구니를 처리하는 서버)가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하는 API Entry(Base URL)와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.

API Entry가 2개 이상일 경우에 각 서버의 기본 URL을 호출하도록 `orderApiRequester`, `orderCartApiRequester`같이 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성해야 한다. 이후 다른 URL로 서비스 코드를 호출할 때 각각의 `apiRequester`를 사용하면 된다.

```typescript
import axios, { AxiosInstance } from "axios";

const defaultConfig = {};

const apiRequester: AxiosInstance = axios.create(defaultConfig);

const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});
const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});

orderApiRequester.get("/order/12345");
// URL: https://api.baemin.or/order/12345

orderCartApiRequester.post("/cart", { itemId: 67890 });
// URL: https://cart.baemin.order/cart
```


### Axios 인터셉터 사용하기
각각의 `requester`는 서로 다른 역할을 담당하는 다른 서버이기 떄문에 `requester`별로 다른 헤더를 설정해줘야 하는 로직이 필요할 수 있다.

이때 인터셉터 기능을 사용하면 `requester`에 따라 비동기 호출 내용을 추가해서 처리할 수 있으며, API 에러를 처리할 때 하나의 에러 객체로 묶어 처리할 수도 있다.

```typescript
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

const getUserToken = () => "";
const getAgent = () => "";
const getOrderClientToken = () => "";
const orderApiBaseUrl = "";
const orderCartApiBaseUrl = "";
const defaultConfig = {};
const httpErrorHandler = () => {};

const apiRequester: AxiosInstance = axios.create({ // 기본 API요청, 독립적인 Axios 인스턴스
  baseURL: "https://api.baemin.com",
  timeout: 5000,
});
// 공통 헤더 설정 함수
const setRequestDefaultHeader = (requestConfig: AxiosRequestConfig) => {
  const config = requestConfig;
  config.headers = {
    ...config.headers,
    "Content-Type": "application/json;charset=utf-8",
    user: getUserToken(),
    agent: getAgent(),
  };
  return config;
};
// 주문 전용? 헤더 설정 함수
const setOrderRequestDefaultHeader = (requestConfig: AxiosRequestConfig) => {
  const config = requestConfig;
  config.headers = {
    ...config.headers,
    "Content-Type": "application/json;charset=utf-8",
    "order-client": getOrderClientToken(),
  };
  return config;
};

// `interceptors` 기능을 사용해 header를 설정하는 기능을 넣거나 에러를 처리할 수 있다
apiRequester.interceptors.request.use(setRequestDefaultHeader); 
// 요청 전에 실행될 인터셉터 설정 - 요청 헤더를 추가 및 수정
// 요청 후 실행될 인터셉터 수정 

const orderApiRequester: AxiosInstance = axios.create({ // 독립적인 Axios 인스턴스
  baseURL: orderApiBaseUrl,
  ...defaultConfig,
});
// 기본 apiRequester와는 다른 header를 설정하는 `interceptors`
orderApiRequester.interceptors.request.use(setOrderRequestDefaultHeader);
// interceptors.request -> 응답 전
// interceptors.response -> 응답 후

// `interceptors`를 사용해 httpError 같은 API 에러를 처리할 수도 있다
orderApiRequester.interceptors.response.use(
  (response: AxiosResponse) => response, // 정상이면 반환
  httpErrorHandler // 에러 발생 시 처리
);

const orderCartApiRequester: AxiosInstance = axios.create({ // 독립적인 Axios 인스턴스
  baseURL: orderCartApiBaseUrl,
  ...defaultConfig,
});
orderCartApiRequester.interceptors.request.use(setRequestDefaultHeader);
```

요청 옵션에 따라 다른 인터셉터를 만들기 위해 **빌더패턴**을 추가하여 `APIBuilder`같은 클래스 형태로 구성하기도 한다.


📢 빌더 패턴(Builder Pattern)
객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나다. 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공한다.

```typescript
import axios, { AxiosPromise } from "axios";

// 임시 타이핑
export type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";

export type HTTPHeaders = any;

export type HTTPParams = unknown;

//
class API {
  readonly method: HTTPMethod;

  readonly url: string;

  baseURL?: string;

  headers?: HTTPHeaders;

  params?: HTTPParams;

  data?: unknown;

  timeout?: number;

  withCredentials?: boolean;

  constructor(method: HTTPMethod, url: string) {
    this.method = method;
    this.url = url;
  }

  call<T>(): AxiosPromise<T> {
    const http = axios.create();
    // 만약 `withCredential`이 설정된 API라면 아래 같이 인터셉터를 추가하고, 아니라면 인터셉터 를 사용하지 않음
    if (this.withCredentials) {
      http.interceptors.response.use(
        (response) => response,
        (error) => {
          if (error.response && error.response.status === 401) {
            /* 에러 처리 진행 */
          }
          return Promise.reject(error);
        }
      );
    }
    return http.request({ ...this });
  }
}

export default API;
```
이처럼 기본 API 클래스로 실제 호출 부분을 구성하고, 위와 같은 API를 호출하기 위한 래퍼를 빌더 패턴으로 만든다.

```typescript
const apiHost = "";

class APIBuilder {
  private _instance: API;

  constructor(method: HTTPMethod, url: string, data?: unknown) {
    this._instance = new API(method, url);
    this._instance.baseURL = apiHost;
    this._instance.data = data;
    this._instance.headers = {
      "Content-Type": "application/json; charset=utf-8",
    };
    this._instance.timeout = 5000;
    this._instance.withCredentials = false;
  }

  // http 메서드에 따라 APIBuilder 객체를 생성하는 메서드들
  static get = (url: string) => new APIBuilder("GET", url);

  static put = (url: string, data: unknown) => new APIBuilder("PUT", url, data);

  static post = (url: string, data: unknown) => new APIBuilder("POST", url, data);

  static delete = (url: string) => new APIBuilder("DELETE", url);

  baseURL(value: string): APIBuilder {
    this._instance.baseURL = value;
    return this;
  }

  headers(value: HTTPHeaders): APIBuilder {
    this._instance.headers = value;
    return this;
  }

  timeout(value: number): APIBuilder {
    this._instance.timeout = value;
    return this;
  }

  params(value: HTTPParams): APIBuilder {
    this._instance.params = value;
    return this;
  }

  data(value: unknown): APIBuilder {
    this._instance.data = value;
    return this;
  }

  withCredentials(value: boolean): APIBuilder {
    this._instance.withCredentials = value;
    return this;
  }

  // 구성된 API 객체를 반환.
  build(): API {
    return this._instance;
  }
}

export default APIBuilder;
```
이와 같은 패턴인 APIBuilder를 사용하는 코드는 다음과 같다.

```typescript
import APIBuilder from "./7.1.4-3";

// ex
type Response<T> = { data: T };
type JobNameListResponse = string[];

const fetchJobNameList = async (name?: string, size?: number) => {
  const api = APIBuilder.get("/apis/web/jobs")
    .withCredentials(true) // 이제 401 에러가 나는 경우, 자동으로 에러를 탐지하는 인터셉터를 사용하게 된다
    .params({ name, size }) // body가 없는 axios 객체도 빌더 패턴으로 쉽게 만들 수 있다
    .build();
  const { data } = await api.call<Response<JobNameListResponse>>();
  return data;
};
```

APIBuilder 클래스는 **보일러플레이트** 코드가 많다는 단점을 갖고 있다. 하지만 옵션이 다양한 경우에 인터셉터를 설정값에 따라 적용하고, 필요 없는 인터셉터를 선택적으로 사용할 수 있다는 장점도 가지고 있다.


📢 보일러플레이트(Boilerplate) 코드
어떤 기능을 사용할 때 반복적으로 사용되는 기본적인 코드를 말한다. 예를 들어 API를 호출하기 위한 기본적인 설정과 인터셉터 등을 설정하는 부분을 보일러플레이트 코드로 간주할 수 있다.


### API 응답 타입 지정하기

같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 앞서 소개한 API의 응답 값은 하나의 Response 타입으로 묶일 수 있다.

```typescript
type FetchCartResponse = unknown;
type PostCartRequest = unknown;
type PostCartResponse = unknown;

export interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string; // FAIL, ERROR errorMessage?: string; // FAIL, ERROR
}
const fetchCart = (): AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get<Response<FetchCartResponse>>("cart");

const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
```

서버에서 오는 응답을 통일해줄 때 주의할 점은 Response 타입을 apiRequester 내에서 처리하려고 할 수 있는데 이렇게 하면 UPDATE나 CREATE와 같이 응답이 없을 수 있는 API를 처리하기 까다로워진다.

```typescript
const updateCart = (
  updateCartRequest: unknown
): AxiosPromise<Response<FetchCartResponse>> => apiRequester.get("cart");
// updateCart 함수는 항상 특정한 <Response<FetchCartResponse> 타입으로 응답을 처리한다.
```
따라서 Response 타입은 apiRequester가 모르게 관리되어야 한다. 

해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 unknown타입을 사용하여 알 수 없는 값임을 표현한다.
```typescript
interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown;
  };
}
```
만약 forPass 안에 프론트 로직에서 사용해야 하는 값이 있다면, 여전히 어떤 값이 들어올지 모르기 때문에 unknown을 유지한다. 로그를 남기거나, 백엔드로 단순히 전달하는 경우라면 값의 타입은 언제든지 변경될 수 있으므로 forPass 내의 값을 사용하지 않아야 한다. 다만, 이미 설계된 프로덕트에서 쓰고 잇는 값이라면 프론트 로직에서 써야 하는 값에 대해서만 타입을 선언한 다음에 사용하는 게 좋다.

```typescript
type ForPass = {
  type: "A" | "B" | "C";
};

const isTargetValue = () => (data.forPass as ForPass).type === "A";
```

### 뷰 모델(View Model) 사용하기

API 응답은 변할 가능성이 크다. 특히 새로운 프로젝트는 서버 스펙이 자주 바뀌기 때문에 뷰 모델을 사용하여 API 변경에 따른 범위를 한정해줘야 한다.

```typescript
interface ListResponse {
  items: ListItem[];
}

const fetchList = async (filter?: ListFetchFilter): Promise<ListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<ListResponse>>();

  return { data };
};
```
해당 API를 사용할 때는 다음처럼 사용한다. 

```typescript
const ListPage: React.FC = () => {
  const [totalItemCount, setTotalItemCount] = useState(0);
  const [items, setItems] = useState<ListItem[]>([]);

  useEffect(() => {
    // 예시를 위한 API 호출과 then 구문
    fetchList(filter).then(({ items }) => {
      setTotalItemCount(items.length);
      setItems(items);
    });
  }, []);

  return (
    <div>
      <Chip label={totalItemCount} />
      <Table items={items} />
    </div>
  );
};
```
흔히 좋은 컴포넌트는 변경될 이유가 하나뿐인 컴포넌트라고 말한다. API 응답의 items 인자를 좀 더 정확한 개념으로 나타내기 위해 `jobItems`나 `cartItems` 같은 이름으로 수정하면 해당 컴포넌트도 수정해야 한다. 이렇게 수정해야할 컴포넌트가 API 1개에 하나라면 좋겠지만, API를 사용하는 기존 컴포넌트도 수정되어야 한다.

이러한 문제를 해결하기 위한 방법으로 뷰 모델을 도입할 수 있다.

```typescript
interface JobListItemResponse {
  name: string;
}

interface JobListResponse {
  jobItems: JobListItemResponse[];
}

class JobList {
  readonly totalItemCount: number;
  readonly items: JobListItemResponse[];

  constructor({ jobItems }: JobListResponse) {
    this.totalItemCount = jobItems.length;
    this.items = jobItems;
  }
}

const fetchJobList = async (
  filter?: ListFetchFilter
): Promise<JobListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<JobListResponse>>();

  return new JobList(data); // 응답 데이터를 뷰 모델로 변환하여 반환
};
```
뷰 모델을 만들면 API 응답이 바뀌어도 UI가 깨지지 않게 개발할 수 있다. 또한 앞의 예시처럼 API 응답에는 없는 `totalItemCount`같은 도메인 개념을 넣을 때 백엔드나 UI에서 로직을 추가하여 처리할 필요 없이 간편하게 새로운 필드를 뷰 모델에 추가할 수 있다.

그러나 뷰 모델 방식에서도 문제가 발생할 수 있다. 추상화 레이어 추가는 결국 코드를 복잡하게 만들며 레이어를 관리하고 개발하는 데도 비용이 든다. 앞의 코드에서 `JobListItemResponse` 타입은 서버에서 지정한 응답 형식이기 때문에 이를 UI에서 사용하려면 다음처럼 많은 타임을 선언해야 한다.

```typescript
interface JobListResponse {
  jobItems: JobListItemResponse[];
}

class JobListItem {
  constructor(item: JobListItemResponse) {
    // JobListItemResponse에서 JobListItem 객체로 변환해주는 코드
  }
}

class JobList {
  readonly totalItemCount: number;
  readonly items: JobListItemResponse[];
  constructor({ jobItems }: JobListResponse) {
    this.totalItemCount = jobItems.length;
    this.items = jobItems.map((item) => new JobListItem(item));
  }
}

const fetchJobList = async (
  filter?: ListFetchFilter
): Promise<JobListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<JobListResponse>>();

  return new JobList(data);
};
```
단순히 API 20개를 추가한다면 20개의 응답이 추가될 것이다. 이 말은 20개 이상 뷰 모델이 추가될 수 있다는 뜻이다. 앞 코드의 `totalItemCount`같이 API 응답에는 없는 새로운 필드를 만들어서 사용할 때, 서버가 내려준 응답과 클라이언트가 실제 사용하는 도메인이 다르다면 서버와 클라이언트 간의 의사소통 문제가 생길 수 있다.

따라서, API응답이 바뀌었을 때는 클라이언트 코드를 수정하는 데 들어가는 비용을 줄이면서도 도메인의 일관성을 지킬 수 있는 절충안을 찾아야한다.

예시
- 꼭 필요한 곳에만 뷰 모델을 부분적으로 만들어서 사용하기
- 백엔드와 클라이언트 개발자가 충분히 소통한 다음 개발하여 API 응답 변화를 최대한 줄이기
- 뷰 모델에 필드를 추가하는 대신 getter 등의 함수를 추가하여 실제 어떤 값이 뷰 모델에 추가한 값인지 알기 쉽게 하기

개발 단계에서는 API 응답 형식이 자주 바뀐다. 또한 응답 값의 탕비이 string이어야하는 데 number가 들어오는 것과 같이 잘못된 타입이 전달되기도 한다. 그러나 타입스크립트는 정적 검사 도구로 런타임에 발생하는 오류를 찾아낼 수 없기 때문에 런타임에 API 응답의 타입오류를 방지하려면 Superstruct 같은 라이브러리를 사용하면 된다.

### Superstruct를 사용해 런타임에서 응답 타입 검증하기
런타임 응답 타입 검증을 하기 위해 사용하는 Superstruct 라이브러리의 소개는 아래와 같다.
- Superstruct를 사용하여 인터페이스 정의와 자바스크립트 데이터의 유효성 검사를 쉽게 할 수 있다.
- Superstruct는 런타임에서의 데이터 유효성 검사를 통해 개발자와 사용자에게 자세한 런타임 에러를 보여주기 위해 고안되었다.

Superstruct의 사용 방법

```typescript
import {
  assert,
  is,
  validate,
  object,
  number,
  string,
  array,
} from "superstruct";

const Article = object({ // 객체형태
  id: number(), // number 타입
  title: string(), // string 타입
  tags: array(string()), // 문자열 배열
  author: object({
    id: number(), // id라는 속성을 가진 객체
  }),
});

const data = {
  id: 34,
  title: "Hello World",
  tags: ["news", "features"],
  author: {
    id: 1,
  },
};

assert(data, Article);
is(data, Article);
validate(data, Article);

```
먼저 `Article`이라는 변수는 Superstruct의 `object()` 모듈의 반환 결과이다. object()라는 모듈 이름에서 예상할 수 있듯이 `Article`은 `object`형태를 가진 무엇가라고 생각할 수 있다.

그렇다면 number(), string() 모듈의 반환 타입도 숫자, 문자열 형태라고 이해할 수 있다.

`assert`, `i`s, `validate`는 각각 '확인', '~이다, '검사하다' 정도로 직역할 수 있는데 3가지 모두 데이터의 유효성 검사를 도와주는 모델이다.

세 모듈의 공통점은 데이터 정보를 담은 data 변수와 데이터 명세를 가진 스키마인 Article을 인자로 받아 데이터가 스키마와 부합하는지를 검사한다는 것인데 차이점은 모듈마다 데이터의 유효성을 다르게 접근하고 반환 값의 형태가 다르다.

- `assert`는 유효하지 않을 경우 에러를 던진다.
- `is`는 유효성 검사 결과에 따라 `true`또는 `false`를 반환한다.
- `validate`는 `[error, data]` 형식의 튜플을 반환한다. 유효하지 않을 때는 에러 값이 반환되고 유효한 경우에는 첫 번째 요소로 `undefined`, 두 번째 요소로 `data value`가 반환된다.



타입스크립트와 어떤 시너지를 발휘하는지 알아보자.

먼저 아래와 같이 `Infer`를 사용하여 기존 타입 선언 방식과 동일하게 타입을 선언할 수 있다.

```typescript
import { Infer, number, object, string } from "superstruct";

const User = object({
  id: number(),
  email: string(),
  name: string(),
});

type User = Infer<typeof User>; // 기존의 타입스크립트 문법
```

Superstruct의 `assert` 메서드를 통해 인자로 받는 `user`가 `User` 타입과 매칭되는지 확인하는 `isUser` 함수이다.

```typescript
type User = { id: number; email: string; name: string };

import { assert } from "superstruct";

function isUser(user: User) {
  assert(user, User);
  console.log("적절한 유저입니다.");
}

const user_A = {
  id: 4,
  email: "test@woowahan.email",
  name: "woowa",
};

isUser(user_A); // 적절한 유저입니다.
```

기대하던 데이터 형식과 달리 런타임에 데이터가 오염되어 들어왔을 때는 아래와 같이 된다.

```tpyescript
const user_B = {
  id: 5,
  email: "wrong@woowahan.email",
  name: 4,
};

isUser(user_B); // error TS2345: Argument of type '{ id: number; email: string; name: number; }' is not assignable to parameter of type '{ id: number; email: string; name: string; }'
```

이처럼 컴파일 단계가 아닌 런타임에서도 적절한 데이터인지를 확인하는 검사가 필요할 때 유용하게 사용할 수 있다.


### 실제 API 응답 시의 Superstruct 활용 사례
Superstruct이 API 응답 시 활용되는 방법을 예시로 알아보자.

`fetchList`의 호출 결과는 `ListItem` 타입의 배열이다. 여기에서는 `ListItem` 타입이 다음가 같다고 가정해보자.

```tpyescript
interface ListItem {
  id: string;
  content: string;
}

interface ListResponse {
  items: ListItem[];
}
const fetchList = async (filter?: ListFetchFilter): Promise<ListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<ListResponse>>();

  return { data };
};
```

우리는 `fetchList` 함수를 호출했을 때 `id`와 `content`가 담긴 `ListItem` 타입의 배열이 오기를 기대한다. 하지만 타입스크립트는 컴파일 타임에 타입을 검증하는 역할을 하기 때문에 타입스크립트만으로는 실제 서버 응답의 형식과 명시한 타입이 일치하는지를 확인할 수 없다.

이때 Superstruct를 활용하여 타입스크립트로 선언한 타입과 실제 런타임에서의 데이터 응답 값을 매칭하여 유효성 검사를 할 수 있다.

```typescript
import { assert } from "superstruct";

function isListItem(listItems: ListItem[]) {
  listItems.forEach((listItem) => assert(listItem, ListItem));
}
```
`isListItem`은 `ListItem`의 배열 목록을 받아와 데이터가 ListItem 타입과 동일한지 확인하고 다를 경우에는 에러를 던진다.



## API 상태 관리하기

### 상태 관리 라이브러리에서 호출하기
상태 관리 라이브러리의 비동기 함수들은 서비스코드를 사용해서 비동기 상태를 변화시킬 수 있는 함수를 제공한다. 컴포넌트는 이러한 함수를 사용하여 상태를 구독하며, 상태가 변경될 때 컴포넌트를 다시 렌더링하는 방식으로 동작한다.

Redux는 비교적 초기에 나온 상태 관리 라이브러리다.

```typescript
import { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";

export function useMonitoringHistory() {
  const dispatch = useDispatch();

  // 전역 Store 상태(RootState)에서 필요한 데이터만 가져온다
  const searchState = useSelector(
    (state: RootState) => state.monitoringHistory.searchState
  );

  // history 내역을 검색하는 함수, 검색 조건이 바뀌면 상태를 갱신하고 API를 호출한다
  const getHistoryList = async (
    newState: Partial<MonitoringHistorySearchState>
  ) => {
    const newSearchState = { ...searchState, ...newState };
    dispatch(monitoringHistorySlice.actions.changeSearchState(newSearchState));
    const response = await getHistories(newSearchState); // 비동기 API 호출하기 dispatch(monitoringHistorySlice.actions.fetchData(response));
  };

  return { searchState, getHistoryList };
}
```
스토어에서 `getHistories API`만 호출하고, 그 결과를 받아와 상태를 업데이트하는 일반적인 방식으로 사용할 수 있다. 그러나 `getHistiryList`함수에서는 `dispatch`코드를 제외하더라도 다음과 같이 API 호출과 상태 관리 코드를 작성해야 한다.

```typescript
enum ApiCallStatus {
  Request,
  None,
}

const API = axios.create();

const setAxiosInterceptor = (store: EnhancedStore) => {
  API.interceptors.request.use((config: AxiosRequestConfig) => {
      const { params, url, method } = config;

      store.dispatch(
        // API 상태 저장을 위해 redux reducer `setApiCall` 함수를 사용한다 // 상태가 `요청됨`인 경우 API가 Loading 중인 상태
        setApiCall({
          status: ApiCallStatus.Request, // API 호출 상태를 `요청됨`으로 변경
          urlInfo: { url, method },
        })
      );
      return config;
    }, (error) => Promise.reject(error)
  );
  // onSuccess 시 인터셉터로 처리한다
  API.interceptors.response.use((response: AxiosResponse) => {
      const { method, url } = response.config;

      store.dispatch(
        setApiCall({
          status: ApiCallStatus.None, // API 호출 상태를 `요청되지 않음`으로 변경
          urlInfo: { url, method },
        })
      );
      return response?.data?.data || response?.data;
    }, (error: AxiosError) => {
      const {
        config: { url, method },
      } = error;
      store.dispatch(
        setApiCall({
          status: ApiCallStatus.None, // API 호출 상태를 `요청되지 않음`으로 변경
          urlInfo: { url, method },
        })
      );
      return Promise.reject(error);
    }
  );
};
```

API를 호출할 때, 호출한 뒤 그리고 호출하고 에러가 발생했을 때 각각 `setApiCall`을 호출해서 상태를 업데이트해야 한다. Redux는 비동기 상태가 아닌 전역 상태를 위해 만들어진 라이브러리기 때문에 미들웨어라고 불리는 여러 도구를 도입하여 비동기 상태를 관리한다. 따라서 보일러플레이트 코드가 많아지는 등 간편하게 비동기 상태를 관리하기 어려운 상황도 발생한다.

반면에 MobX 같은 라이브러리에서는 이러한 불편함을 개선하기 위해 비동기 콜백 함수를 분리하여 액션으로 만들거나 `runInAction`과 같은 메서드를 사용하여 상태 변경을 처리한다. 또한, `async/await`나 `flow`같은 비동기 상태 관리를 위한 기능도 있어 더욱 간편하게 사용할 수 있다.

```typescript
import { runInAction, makeAutoObservable } from "mobx";
import type Job from "models/Job";

class JobStore {
  job: Job[] = [];
  constructor() {
    makeAutoObservable(this);
  }
}

type LoadingState = "PENDING" | "DONE" | "ERROR";

class Store {
  job: Job[] = [];
  state: LoadingState = "PENDING";
  errorMsg = "";

  constructor() {
    makeAutoObservable(this);
  }

  async fetchJobList() {
    this.job = [];
    this.state = "PENDING";
    this.errorMsg = "";
    try {
      const projects = await fetchJobList();
      runInAction(() => {
        this.projects = projects;
        this.state = "DONE";
      });
    } catch (e) {
      runInAction(() => {
        this.state = "ERROR";
        this.errorMsg = e.message;
      });
    }
  }
}
```

상태 관리 라이브러리에서 비동기 처리 함수를 호출하기 위해 액션이 추가될 때마다 관련된스토어나 상태가 계속 늘어난다. 이로 인해 전역 상태 관리자가 모든 비동기 상태에 접근하고 변경할 수 있다는 것이 문제인데 만약 2개 이상의 컴포넌트가 구독하고 있는 비동기 상태가 있다면 쓸데없는 비동기 통신이 발생하거나 의도치 않은 상태 변경이 발생할 수 있다.


### 훅으로 호출하기

react-query나 useSwr 같은 훅을 사용한 방법은 상태 관리 라이브러리를 사용한 방식보다 훨씬 간편한데, 이러한 훅은 캐시를 사용하여 비동기 함수를 호출하며, 상태 관리 라이브러리에서 발생했던 의도치 않은 상태 변경을 방지하는 데 도움이 된다. 

아래 코드는 `Job`목록을 불러오는 훅과 `Job` 1개를 업데이트하는 예시이다. 
react-query에서는 `onSuccess`옵션의 `invalidateQueries`를 사용하여 특정 키의 API를 유효하지 않은 상태로 설정할 수 있다.

```typescript
// Job 목록을 불러오는 훅
const useFetchJobList = () => {
  return useQuery(["fetchJobList"], async () => {
    const response = await JobService.fetchJobList(); // View Model을 사용해서 결과
    return new JobList(response);
  });
};

// Job 1개를 업데이트하는 훅
const useUpdateJob = (
  id: number,
  // Job 1개 update 이후 Query Option
  { onSuccess, ...options }: UseMutationOptions<void, Error, JobUpdateFormValue>
): UseMutationResult<void, Error, JobUpdateFormValue> => {
  const queryClient = useQueryClient();

  return useMutation(
    ["updateJob", id],
    async (jobUpdateForm: JobUpdateFormValue) => {
      await JobService.updateJob(id, jobUpdateForm);
    },
    {
      onSuccess: (
        data: void, // updateJob의 return 값은 없다 (status 200으로만 성공 판별) values: JobUpdateFormValue,
        context: unknown
      ) => {
        // 성공 시 ‘fetchJobList’를 유효하지 않음으로 설정 queryClient.invalidateQueries(["fetchJobList"]);
        onSuccess && onSuccess(data, values, context);
      },
      ...options,
    }
  );
};
```

이후 컴포넌트에서 일반적인 훅을 호출하는 것처럼 사용하면 된다. `JobList`컴포넌트가 반드시 최신 상태를 표현하려면 폴링(polling)이나 웹소켓(websocket)등의 방법을 사용해야 한다. 


📢 폴링(polling)
클라이언트가 주기적으로 서버에 요청을 보내 데이터를 업데이트하는 것. 클라이언트는 일정한 시간 간격으로 서버에 요청을 보내고, 서버는 해당 요청에 대해 최신 상태의 데이터를 응답으로 보내주는 방식.

간단한 폴링방식으로 최신 상태를 업데이트하는 예시
```typescript
const JobList: React.FC = () => {
  // 비동기 데이터를 필요한 컴포넌트에서 자체 상태로 저장
  const {
    isLoading,
    isError,
    error,
    refetch,
    data: jobList,
  } = useFetchJobList();

  // 간단한 Polling 로직, 실시간으로 화면이 갱신돼야 하는 요구가 없어서 // 30초 간격으로 갱신한다
  useInterval(() => refetch(), 30000);

  // Loading인 경우에도 화면에 표시해준다
  if (isLoading) return <LoadingSpinner />;

  // Error에 관한 내용은 11.3 API 에러 핸들링에서 더 자세하게 다룬다
  if (isError) return <ErrorAlert error={error} />;

  return (
    <>
      {jobList.map((job) => (
        <Job job={job} />
      ))}
    </>
  );
};
```

상태 관리 라이브러리에서는 비동기 상태를 변경하는 코드가 점점 추가되면 전역 상태 관리 스토어가 비대해지기 때문에 단순히 상태를 변경하는 액션이 증가하는 것뿐만 아니라 전역 상태 자체도 복잡해진다.

예를 들어 에러 발생, 로딩 중 등과 같은 상태는 전역으로 관리할 필요가 거의 없다. 다른 컴포넌트가 에러 상태인지, 성공 상태인지를 구독하는 경우 컴포넌트의 결합도와 복잡도가 높아져 유지보수를 어렵게 만들 수 있다. 이런 고민으로 인해 비동기 통신을 react-query를 사용해서 처리할 수 있는데 react-query는 전역 상태 관리 라이브러리가 아닌 만큼 상태 관리 라이브러리 중에서 가장 뛰어나다는 의미가 아니다.
어떤 상태 관리 라이브러리를 선택할지는 프로젝트의 도메인, 개발자의 학습 곡선 그리고 기존 코드와의 호환성 등에 따라 달라질 수 있다.


## API 에러 핸들링

비동기 API 호출을 하다 보면 상태 코드에 따른 에러 혹은 CORS 에러 등 다양한 에러가 발생할 수 있다.













