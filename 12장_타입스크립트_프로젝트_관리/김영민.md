# 12장 타입스크립트 프로젝트 관리

----------------
## 12.1.1 앰비언트 타입 활용하기

### 1️⃣ 앱비언트 타입 선언하기
타입스크립트의 타입 선언은 보통 ts나 tsx인데 .d.ts 확장자를 가진 파일에서도 선언할 수 있다. 

.d.ts 확장자로 만들어진 파일에서는 타입만 선언할 수 있다. 값을 포함할 수 없다는 것을 알리기 위해 .d.ts 라는 확장자를 가진
파일을 만들고 이를 앰비언트(ambient) 타입 선언이라고 부른다. 

앱비언트 타입 선언으로 값을 정의할 수 없지만 declare 키워드를 사용해 어딘가에 자바스크립트 값이 존재한다는 사실을 선언할 수 있다.
```ts
declare는 타입스크립트 컴파일러에 어떤 것의 존재 여부를 명시하기 위한 역할을 한다.
단순히 존재 여부만 알려주기 때문에 컴파일 대상이 아님
```

**대표적인 앱비언트 타입 선언 활용 사례**

간혹 파일을 임포트할때 오류가 난 적이 있을 것이다. 특히 이미지 부분에서 오류가 발생하곤하는데 이는 타입스크립트의 특성으로 .ts와 .js 외의 파일은 인식하지 못한다.
이런 상황에서 타입스크립트의 declare 키워드를 사요해 아래와 같이 특정 형식을 모듈로 선언하면 타입스크립트 컴파일러에 미리 정보를 제공해 에러를 수정할 수 있다. 
```ts
declare module "*.png" {
  const src: string;
  export default src;
}
```
declare 키워드는 이미 존재하지만 타입스크립트가 알지 못하는 부분을 컴파일러에 '이런 것이 존재한다'라고 알려주는 역할을 한다.

### 자바스크립트로 작성된 라이브러리
자바스크립트로 작성된 npm 라이프러리있다고 가정한다면 자바스크립트로 구현되어 타입 선언이 존재하지 않을 것이다. 
타입스크립트에서 이 라이브러리를 사용은 할 수 있지만 타입 정보가 없어 모두 any로 추론된다. tsconfig에서 any를 사용하지 못하게 하면 빌드되지 않을 것이다.

이런 경우 앰비언트 타입 선언을 활용하여 자바스크립트 라이브러리 내부 함수와 변수의 타입을 앰비언트로 선언하면 타입스크립트는 자동으로 .d.ts 확장자를 가진 파일을 검색하여 타입 검사를 진행하게 되어 문제없이 컴파일이 가능하다.

**ex**

@types/react를 이용하여 리액트 컴포넌트와 훅에 대한 타입을 정의할 수 있다. 또한 tsc는 별도의 설정 없이도 node_modules/@types 디렉터리에 있는 타입 선언을 타입 검사에 활용한다.

즉 앰비언트 타입 선언은 타입스크립트에게 '자바스크립트 코드 안에는 이런 정보가 있다'라고 알려주는 도구이다.

### 타입스크립트로 작성된 라이브러리

타입스크립트로 작성된 라이브러리는 자바스크립트와 .d.ts 파일로 배포된 것이 일반적이다.

타입스크립트 파일을 직접 배포하여 라이브러리 사용자가가 타입스크립트를 컴파일할 때 자바스크립트 파일과 .d.ts 파일로 배포하면 라이브러리 코드를 따로 컴파일하지 않아도 되기 때문에 컴파일 시간을 크게 줄일 수 있다.
또한 개발자는 .d.ts 파일에 정의된 타입 정보를 활용할 수 있다. tsconfig 파일의 declaration을 true로 설정히면 타입스크리븥 컴파일러는 자동으로 .d.ts 파일을 생성한다.

### 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때

타입스크립트로 직접 구현하지 않았지만 실제 자바스크립트 어딘가 전역 변수가 정의되어 있는 상황을 타입스크립트에 알릴 때 앰비언트 타입 선언을 사용한다.

예를 들어 웹뷰를 개발할 때 네이티브 앱과 통신을 위한 인터페이스를 네이티브 앱이 Window 객체에 추가하는 경우가 많다. 
이렇게 전역 객체인 Window에 변수나 함수를 추가하면 타입스크립트에서 직접 구현하지 않아도 실제 런타임 환경에서 해당 변수를 사용할 수 있다.

네이티브 앱에서 window 전역 객체에 deviceID나 appVersion 같은 값을 할당하는 시나리오를 예로들면,
window 객체의 속성은 타입스크립트에서 정의한 것이 아니기 때문에 해당 속성이 window 객체의 타입에 조내하지 않는다고 판단한다.
해당 속성에 접근하려고 하면 window 객체에 존재하지 않는 속성이라 에러가 발생한다.
이때 global namespace에 있는 Window 객체에 해당 속성이 정의되어 있다는 것을 나타내기 위해 앰비언트 타입 선언을 사용한다.
```ts
declare global {
  interface Window {
    device: string | undefined;
    appVersion: string;
  }
}
```

## 12.1.2 앱비언트 타입 선언 시 주의점

**타입스크립트로 만드는 라이브러리에는 불필요**

tsconfig의 declaration을 true로 설정하면 .d.ts를 자동을 생성하기에 직접 작성할 필요가 없다. 

**전역으로 타입을 정의하여 사용할 때 주의해야 할 점**

서로 다른 라이브러리에서 동일한 이름의 앱비언트 타입 선언을 한다면 충돌이 발생하여 어떤 타입 선언이 적용될 알기 어렵다.
또한 명식적인 임포트나 익스포트가 없기에 코드의 의존성 관계가 명확하지 않아 변경할 때 어려울 수 있다.

## 12.1.3 앰비언트 타입 선언을 잘 못 사용했을 때의 문제점

앰비언트 타입은 명식적인 임포트나 익스포트가 없기 때문에 의존성 관계를 특정하기 힘들다. 
.ts 파일 내의 앰비언트 변수 선언은 전역에 적용되는 특성으로 개발자에게 혼란을 야기할 수 있다. 

## 12.1.4 앰비언트 타입 활용하기

타입스크립트 컴파일러에 타입 정보를 알려주는 declare 키워드를 더 효과적으로 활용할 수 있는 방법

**타입을 정의하여 임포트 없이 전역으로 공유**

.d.ts 파일에서 앰비언트 타입 선언은 전역 변수와 같은 역할을 한다.
따라서 임포트하지 않고 사용할 수 있고 이런 특성으로 내장된 유틸리티 함수를 사용하는 것 처럼 사용할 수 있다.
```ts
// src/index.ts
type Optional<T extends object, k extends keyof T = keyof T> = Omit<T, K> & Partial<Pick<T, K>>;


// src/components.ts
type Props = { name: string; age: number; visible: boolean };
type OptionalProps = Optional<Props>; // Expect: { name?: string age?: number; visible?: boolean;}
```

**declare type 활용하기**
보편적으로 많이 사용하는 커스텀 유틸리티 타입을 declare type으로 선언하여 전역에서 사용할 수 있다.
아래 예시 처럼 Nullable 타입을 선언해서 어디에서든 쉽게 사용할 수 있다.
```ts
declare type Nullable<T> = T | null;

const name: Nullable<string> = "woowa";
```

**declare module 활용하기**

CSS-in-JS 라이브러리의 사례를 살표보자. theme의 인터페이스 타입을 확장하여 theme 타입이 자동으로 완성되도록 하는 기능이 추가되었다. 
CSS-in-JS 라이브러리는 기존의 폰트 크기, 색상 등을 객체로 관리한다. 이렇게 정의된 theme에서 스타일 값을 가져와 기존 인터페이스 타입과 통합하여 theme 타입이 자동으로 완성되는 기능을 지원하고 있다.

```ts
const fontSizes = {
  xl: "30px"
};
const colors = {
  gray_100: "#222222",
  gray_200: "#444444"
};
const depths = {
  origin: 0,
  foreground: 10,
  dialog: 100,
}
const theme = {
  fontSizes,
  colors,
  depths
};

declare module "styled-components" {
  type Theme = typeof theme;
  
  export interface DefaultTheme extends Theme {}
}
```

**declare namespace 활용하기**

Node 환경에서.env 파일을 사용할 때, declare namespace를 활영하여 process.env로 설정해 값을 손쉽게 불러오고 환경변수의 자동 완성 기능을 쓸 수 있다.
```ts
declare namespace NodeJS {
  interface ProcessEnv {
    readonly API_URL: string;
    readonly API_INTERNAL_URL: string;
  }
}
```
위와 같은 접근방식은 as단언을 사용하지 않을 수 있다.

**declare global 활용하기**

declare global 키워드는 전역 변수를 선언할 때 사용한다. 예를 들어 Window 객체의 스코프에 사용되는 모듈이나 변수를 추가할 수 있다.
```ts
declare global {
  interface Window {
    newProperty: string;
  }
}
```
앞의 코드처럼 전역 변수인 Window 객체에 newProperty 속성을 추가한 것과 같은 동작을 구현할 수 있다. 
대표적으로 네이티브 앱과의 통신을 위한 인터페이스를 Window 객체에 추가할 때 앰비언트 타입 선언을 할 수 있다. 

```ts
declare global {
  interface Window {
    webkit?: {
      messageHandlers?: Record<string,
        {
          postMessage?: (parameter: string) => void;
        }>;
    };
  }
}
```
위 코드는 IOS 웹뷰에서 자바스크립트로 네이티브 앱과 통신을 위한 함수를 호출할 때, 자동 완성 기능을 활용하여 실수를 줄일 수 있다. 

## 12.1.5 declare와 번들러의 시너지

declare global로 전역 변수를 선언하는 과정과 번들러를 통해 데이터를 주입하는 절차를 함께 활용하면 시너지를 낼 수 있다.
```ts
const color = {
  white: "#ffffff",
  black: "#000000"
} as const;

type ColorSet = typeof color;

declare global {
  const _color: ColorSet;
}
```
전역에 _color라는 변수가 존재함을 타입스크립트 컴파일러에 알리면 해당 객체를 활용할 수 있다.
```ts
const white = _color["white"];
```
하지만 아직 ColorSet 타입을 가지고 있는 _color 객체의 실제 데이터가 존재하지 않는다.
다시 말해 앞의 코드는 타입스크립트 에러를 발생시키지 않지만, 코드가 실행될 경우에는 실제 데이터가 없기 때문에 기대하는 동작과 다를 수 있다. 

이런 문제를 해결하려면 번들 시점에 번들러를 통해 해당 테이터를 주입하는 것으로 해결할 수 있다.

다음은 롤업(rollup) 번들러의 inject 모듈로 데이터를 주입하는 예시를 나타낸 것이다. 
우선 전체적인 폴더 구조는 아래와 같다.
```bash
├── node_moduless
│   ├── ...
├── data.ts
├── index.ts
├── type.ts
├── type.ts
``` 
### data.ts
```ts
export const color = {
  white: "#ffffff",
  black: "#000000"
} as const;
```
### type.ts
```ts
import { color } from "./data.ts"
type ColorSet = typeof color;

declare global {
  const _color: ColorSet;
}
```
### index.ts
```ts
console.log(_color["white"]);
```
### rollup.config.js
```ts
import inject from "@rollup/plugin-inject";
import typescript from "@rollup/plugin-typescript";

export default [
  {
    input: "index.ts",
    output: [
      {
        dir: "lib",
        format: "esm",
      },
    ],
    plugins: [typescript(), inject({ _color: ["./data", color]})],
  }
]
```
전체적인 흐름을 살펴보면 data.ts에서 색상을 정의하고 있으며 type.ts에서는 해당 데이터로부터 타입을 정의하여 전역적으로 선언하고 있다. 

index.ts 파알에서는 전역 타입으로 선언된 변수인 _color['white']를 콘솔로 출력하고 있다. 그리고 가장 중요한 롤업 번들러 설정에서 inject 모듈을 사용하여 _color에 해당하는 데이터를 삽입하고 있다. 

✅ **inject 모듈**
```
inject는 임포트문의 경로를 분석하여 데이터를 가져온다.
import { color } from "./data";

./data 경로에서 color를 가져오는 경우, .['./data', 'color']]로 지정하여 어떤 데이터 값을 가져올지 명시할 수 있다.
```

## 12.2 스크립트와 설정 파일 활용하기
타입스크립트 프로젝트에서 스크립트와 tsconfig 등을 잘 활용하면 개발 생산성을 높일 수 있다.

### 12.2.1 스크립트 활용하기
**실시간으로 타입을 검사**

일반적으로 타입스크립트 프로젝트는 에디터가 가능한 빠르게 타입 에러를 감지해준다. 그러나 컴퓨터 성능이 떨어지거나 프로젝트 규모가 커지면 에이터가 타입 에러를 알려주는 속도가 느려진다.
때로는 검사하려는 파일을 열어야 타입 에러가 나타나기도 하고, 에디터에서 에러가 없다고 확인하고 커밋을 했지만 뒤늦게 깃훅 도구인 husky에 의해 타입 에러가 발견되기도 한다.

```
yarn tsc --noEmit --incremental -w
```
이 스크립트는 프로젝트의 tsc를 실행한다.
- noEmit 옵션은 자바스크립트로 된 출력 파일을 생성하지 않도록 설정한 것이다.
- incremental 옵션은 증분 컴파일을 활용하여 컴파일 시간을 단축할 수 있게 해준다.
- w는 파일 변경 사항을 모니터링한다는 의미이다.

✅ 증분 컴파일
```
매번 모든 대상을 컴파일하는 것이 아니라 변경 사항이 있는 부분만 컴파일하는 것을 말하며, 이를 활용하면 컴파일 시간을 줄일 수 있다. 
```

**타입 커버리지 확인**

타입스크립트를 사용하면서 any 타입을 이곳저곳에서 남발하면 타입스크립트의 장점을 활용하지 못할 수 있다.
```
npx type-coverage --detail
```
프로젝트의 모든 부분이 타입스크립트 통제하에 돌아가고 있는지 판단하기 위한 스크립트
이 스크립트를 사용하면 현재 프로젝트의 타입 커버리지와 any를 사용하고 있는 변수의 위치가 나타난다.

![Image](https://github.com/user-attachments/assets/a7f6f20a-98e6-4e5a-b32d-0b7bf390ddc5)

그림을 보면 전체의 약 85.78%에 해당하는 변수가 타입을 지정되어 있음을 확인할 수 있다. 약 14%는 any로 선언되어 있다는 것이다.

### 12.2.2 설정 파일 활용하기
**타입스크립트 컴파일 속도 높이기**

앞서 설명한 증분 컴파일이 확성화되면 매번 모든 코드를 비교하는 것이 아니라 수정된 부분만 컴파일하여 컴파일타임을 줄일 수 있다. 

- tsconfig 파일에 설정 추가
```
// tsconfig에 추가
{
  "compilerOptions": {
    ...
    incremental: true
  }
}
```
- 스크립트 활용
```
yarn tsc --noEmit --incremental --diagnostic 
```

### 12.2.3 에디터 활용하기
**에디테에서 타입스크립트 서버 재시작하기**

자바스크립트 IDE에서 간혹 정의된 타입 객체가 임포트되지 않을 경우가 있는데 이런 상황에서 Restart TS server 기능을 활용할 수 있다.

vsCode의 경우
⌨️ 단축키: Command + Shift + P(윈도우: Ctrl + Shift + P)

webStorm TypeScript tool window -> TypeScript -> Restart TypeScript Service

## 12.3 타입스크립트 마이그레이션

### 12.3.1 타입스크립트 마이그레이션의 필요성

우선 타입스크립트를 새로운 기술 스택으로 도입해도 반드시 마이그레이션 해야하는 것은 아니다.
타입스크립트로 새롭게 구축하는 것이 자바스크립트를 타입스크립트로 마이그레이션하는 것에 비해 새로운 설계를 바탕으로 타입을 작성하는 게 더 효율적이기 때문이다.

빠르게 변화하는 비즈니스 환경에서 기존 코드의 한계가 드러날 수 있다.
이런 상황에서 자바스크립트 코드를 타입스크립트 코드로 변환하면 비즈니스 로직에 맞지 않는 인터페이스만 추가하는 작업에 불과할 수 있ㅅ다.
설령 성공적으로 마이그레이션에 성공한다고 해도 타입스크립트의 장점을 충분하게 활용하기 어려울 수 있다.

따라서 상황에 맞는 비즈니스 요구 사항의 반영할 수 있는 설계 기반 타입을 작성하는게 효율적이다.
프로젝트 규모와 특성 및 내외부 여건에 맞춰 종합적으로 신중하게 따져봐야 한다.

### 12.3.2 점진적인 마이그레이션

마이그레이션은 하루아침에 완료할 수 없다. 따라서 작은 부분부터 시작해 점차 범위를 넓혀가며 진행해야한다.
작은 부분부터 마이그레이션을 시작할 수 있기 때문에 진입 장벽이 나아지고 프로젝트의 전반적인 동작을 안정적으로 유지할 수 있다.

하지만 단순히 allowJS를 true, noImplicitAny를 false로 설정하면 무기한으로 마이그레이션을 미룰 수 있어 지양해야한다. 

### 12.3.3 마이그레이션 진행하기
1. 타입스크립트 개발 환경을 선정, 빌드 파이프라인에 타입스크립트 컴파일러를 통합한다. tsconfig 파일에서 allowJS를 true로 noImplicitAny를 false로 설정해야 한다. allowJS는 자바스크립트 파일을 컴파일할 때 사용하는 옵션으로, 기존 자바스크립트 함수를 타입스크립트에서 임포트하거나 반대로 타입스크립트 함수를 자바스크립트에서 임포트할 수 있게 해준다.
noImplicitAny는 암시적 any 타입이 있을 때 오류가 발생하게 하는 옵션으로 점진적으로 추가하는 과정에서 오류가 발생하지 않도록 noImplicitAny를 false로 설정해야 한다.
2. 작성된 자바스크립트 파일을 타입스크립트 파일로 변환한다. 이 단계에서는 필요한 타입과 인터페이스를 하나씩 정의하며 함수 시그니처를 추가해 나간다.
3. 기존 자바스크립트 파일을 모두 타입스크립트로 변환하는 작업이 완료되었다면 tsconfig 파일에서 allowJS를 false로 변경하고, noImplicitAny를 true로 설정하여 타입이 명시되지 않은 부분이 없는지 점검한다. 

## 12.4 모노레포
여러 프로젝트를 관리하는 경우에는 일반적으로 개별 프로젝트마다 별도의 레포지토리를 생성하여 관리한다.
이떄 프로젝트마다 고유하고 독립적인 코드가 존재한다면 통합이 필요하지 않을 수 있다.
하지만 공통된 요소를 찾아낼 수 있다면 이를 통합하여 조금 더 효율적으로 관리할 수 있다.

### 12.4.1 분산된 구조의 문제점
독립적인 3개의 프로젝트가 있고 각 레포지토리에서 해당 프로젝트들의 jest, 바벨, EsLint, 타입스크립트 등의 설정 파일을 별도로 구성하고 빌드 파이프라인, 공통적인 프로젝트에 필요한 소스코드를 관리하고 있다면, 
한 프로젝트의 기능을 다른 프로젝트로 복제하여 빠르게 구현할 수 있다.

개발시간을 아낄 수 있지만 프로젝트 관리 측면에서 어려움이 생길 수 있다. 여러 프로젝트에서 동일한 코드를 복사했는데 뒤늦게 버그가 발견되면 일일히 모든 프로젝트를 수정해야 한다. 

따라서 개발자가 변경이 필요한 지점을 모두 인지하고 있어야하며 이는 개발자 경험(DX)가 저하될 수 있다.
분산된 구조는 생산성을 떨어뜨리는 결과를 초래한다. 이런 상황에서 벗어나기 위해서는 반복되는 코드를 함수화하여 통합하듯이 한 곳에서 프로젝트를 관리할 수 있도록 통합해야한다.

### 12.4.2 통합할 수 있는 요소 찾기
모든 요소를 통합할 수 있다면 이상적이겠지만, 완전히 동일한 프로젝트가 아니라면 프로젝트마다 요소가 다르기 마련이다.
따라서 프로젝트 내에서 공통으로 통합할 수 있는 요소를 찾아야 한다.

![Image](https://github.com/user-attachments/assets/ef436381-bf50-4895-9a92-4b4db8467f8e)
➡️ 프로젝트별 utils 디렉토리

각 프로젝트의 utils 디렉토리는 위 그림과 같다. clipboard, date, logger, validation 파일은 통합할 수 있는 파일로 보이지만 파일 소스코드는 같지 않다면 통합을 위해 일부를 수정해야한다. 

### 12.4.3 공통 모듈화로 관리하기
소스코드를 수정한 다음 모듈화를 통해 통합할 수 있다. 이 과정에서 npm과 같은 패키지 관리자를 활용하여 공통 모듈을 생성하고 관리한다면 각 프로젝트에서 간편하게 모듈과 의존성을 맺고 사용할 수 있게 된다. 
새로운 프로젝트를 시작하더라도 모듈을 통해 코드를 재사용할 수 있으며, 특정 기능의 변경이 필요할 때는 해당 모듈의 소스코드만 수정하면 되기 때문에 유지보수도 쉬어진다.

![Image](https://github.com/user-attachments/assets/2e22aa18-339a-4c8c-b8ff-311134257c8a)

공통 모듈화를 통해 단순한 코드 복사 작업은 줄었지만 여전히 아쉬운 점이 있다. 만약 공통 모듈에 변경이 발생한다면 해당 모듈을 사용하는 프로젝트에서도 추가 작업이 필요할 수 있다.
또한 공통 모듈의 개수가 늘어나면 관리해야 할 레포지톨만 늘어난다.

새로운 공통 모듈이 필요하다면 개발자는 새로운 레포지토리를 생성하고 개발 환경을 설정하며 패키지 관리자를 사용하여 모듈을 게시해야 한다. 
새로운 프로젝트를 시작할 때도 빌드를 위한 CI/CD 파이프라인, Lint, 테스트 등도 별도로 설정해야 한다.

### 12.4.4 모노레포의 탄생
모노레포란 버전 관리 시스템에서 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하는 소프트웨어 개발 전략이다. 이전에는 다양한 기능을 가진 프로젝트를 하나의 레포지토리로 관리하는 모놀리식 기법을 주로 사용한다.
하지만 모놀리식 구조는 코드 간의 직접적인 의존이 발생하면 로직이 조금만 변경되도 전체 프로젝트의 영향을 줄 수 있다.
따라서 설계적인 측면과 빌드 및 배포 등에서 효율적이지 못했다.

효율적인 구조에 대한 수요는 거대한 프로젝트를 작은 프로젝트의 집합으로 나누어 관리하는 폴리레포 방식과 하나의 레포지토리로 모든 것을 관리하는 모노레포 방식이 생겨났다.
최근에는 프로젝트에서 번들러, 테스트, Lint, CI/CD 스크립트나 도커 등 다양한 설정을 적용한다.

이러한 상황에서 모노레포를 사용하면 개발 환경 설정도 통합할 수 있어서 더 효율적인 관리가 가능하다.

✅ 모노레포로 관리했을 때의 장점

여러 프로젝트를 하나의 레포지토리로 통합하여 관리하며, 프로젝트마다 개별적인 레포지토리를 만드는 방식과 달리 Lint, CI/CD 등 개발 환경 설정도 통합적으로 관리하기 때문에 코드 중복을 줄여준다.

개별적으로 프로젝트를 형성하는 폴리레포와 다르게 공통 모듈도 돌일한 프로젝트 내에서 관리되므로 별도의 패키지 관리자를 통해 모듈을 게시하지 않아도 된다. 
따라서 기능 변화를 쉽게 추적하고 의존성을 관리할 수 있게 된다.

✅ 모노레포로 관리했을 때의 단점

시간이 지남에 따라 레포지토리가 거대해질 수 있다. 
레포지토리에 여러 팀의 이해관계가 얽혀있다면 소유권과 권한 관리가 복잡해질 수 있다.
따라서 각 프로젝트나 모듈의 소유권을 명확히 정의하고 규칙을 설정해야 하는 과정이 별도로 필요하다. 
